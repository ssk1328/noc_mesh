//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Wed May  7 17:28:05 IST 2014
//
// Method conflict info:
// Method: imem_server_request_put
// Conflict-free: imem_server_response_get
// Conflicts: imem_server_request_put
//
// Method: imem_server_response_get
// Conflict-free: imem_server_request_put
// Conflicts: imem_server_response_get
//
//
// Ports:
// Name                         I/O  size props
// RDY_imem_server_request_put    O     1 reg
// imem_server_response_get       O    39 reg
// RDY_imem_server_response_get   O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// imem_server_request_put        I     7 reg
// EN_imem_server_request_put     I     1
// EN_imem_server_response_get    I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkImem(CLK,
	      RST_N,

	      imem_server_request_put,
	      EN_imem_server_request_put,
	      RDY_imem_server_request_put,

	      EN_imem_server_response_get,
	      imem_server_response_get,
	      RDY_imem_server_response_get);
  parameter [3 : 0] procId = 4'b0;
  input  CLK;
  input  RST_N;

  // action method imem_server_request_put
  input  [6 : 0] imem_server_request_put;
  input  EN_imem_server_request_put;
  output RDY_imem_server_request_put;

  // actionvalue method imem_server_response_get
  input  EN_imem_server_response_get;
  output [38 : 0] imem_server_response_get;
  output RDY_imem_server_response_get;

  // signals for module outputs
  wire [38 : 0] imem_server_response_get;
  wire RDY_imem_server_request_put, RDY_imem_server_response_get;

  // ports of submodule instReqQ
  wire [6 : 0] instReqQ$D_IN, instReqQ$D_OUT;
  wire instReqQ$CLR,
       instReqQ$DEQ,
       instReqQ$EMPTY_N,
       instReqQ$ENQ,
       instReqQ$FULL_N;

  // ports of submodule instRespQ
  wire [38 : 0] instRespQ$D_IN, instRespQ$D_OUT;
  wire instRespQ$CLR,
       instRespQ$DEQ,
       instRespQ$EMPTY_N,
       instRespQ$ENQ,
       instRespQ$FULL_N;

  // ports of submodule mem
  wire [31 : 0] mem$D_IN, mem$D_OUT_1;
  wire [5 : 0] mem$ADDR_1,
	       mem$ADDR_2,
	       mem$ADDR_3,
	       mem$ADDR_4,
	       mem$ADDR_5,
	       mem$ADDR_IN;
  wire mem$WE;

  // rule scheduling signals
  wire CAN_FIRE_RL_access,
       CAN_FIRE_imem_server_request_put,
       CAN_FIRE_imem_server_response_get,
       WILL_FIRE_RL_access,
       WILL_FIRE_imem_server_request_put,
       WILL_FIRE_imem_server_response_get;

  // action method imem_server_request_put
  assign RDY_imem_server_request_put = instReqQ$FULL_N ;
  assign CAN_FIRE_imem_server_request_put = instReqQ$FULL_N ;
  assign WILL_FIRE_imem_server_request_put = EN_imem_server_request_put ;

  // actionvalue method imem_server_response_get
  assign imem_server_response_get = instRespQ$D_OUT ;
  assign RDY_imem_server_response_get = instRespQ$EMPTY_N ;
  assign CAN_FIRE_imem_server_response_get = instRespQ$EMPTY_N ;
  assign WILL_FIRE_imem_server_response_get = EN_imem_server_response_get ;

  // submodule instReqQ
  FIFO2 #(.width(32'd7), .guarded(32'd1)) instReqQ(.RST_N(RST_N),
						   .CLK(CLK),
						   .D_IN(instReqQ$D_IN),
						   .ENQ(instReqQ$ENQ),
						   .DEQ(instReqQ$DEQ),
						   .CLR(instReqQ$CLR),
						   .D_OUT(instReqQ$D_OUT),
						   .FULL_N(instReqQ$FULL_N),
						   .EMPTY_N(instReqQ$EMPTY_N));

  // submodule instRespQ
  FIFO2 #(.width(32'd39), .guarded(32'd1)) instRespQ(.RST_N(RST_N),
						     .CLK(CLK),
						     .D_IN(instRespQ$D_IN),
						     .ENQ(instRespQ$ENQ),
						     .DEQ(instRespQ$DEQ),
						     .CLR(instRespQ$CLR),
						     .D_OUT(instRespQ$D_OUT),
						     .FULL_N(instRespQ$FULL_N),
						     .EMPTY_N(instRespQ$EMPTY_N));

  // submodule mem
  RegFileLoad #(.file((procId == 4'd0) ?
			"../data/imem/imem_init_0.txt" :
			((procId == 4'd1) ?
			   "../data/imem/imem_init_1.txt" :
			   ((procId == 4'd2) ?
			      "../data/imem/imem_init_2.txt" :
			      ((procId == 4'd3) ?
				 "../data/imem/imem_init_3.txt" :
				 ((procId == 4'd4) ?
				    "../data/imem/imem_init_4.txt" :
				    ((procId == 4'd5) ?
				       "../data/imem/imem_init_5.txt" :
				       ((procId == 4'd6) ?
					  "../data/imem/imem_init_6.txt" :
					  "../data/imem/imem_init_.txt"))))))),
		.addr_width(32'd6),
		.data_width(32'd32),
		.lo(6'd0),
		.hi(6'd63),
		.binary(32'd0)) mem(.CLK(CLK),
				    .ADDR_1(mem$ADDR_1),
				    .ADDR_2(mem$ADDR_2),
				    .ADDR_3(mem$ADDR_3),
				    .ADDR_4(mem$ADDR_4),
				    .ADDR_5(mem$ADDR_5),
				    .ADDR_IN(mem$ADDR_IN),
				    .D_IN(mem$D_IN),
				    .WE(mem$WE),
				    .D_OUT_1(mem$D_OUT_1),
				    .D_OUT_2(),
				    .D_OUT_3(),
				    .D_OUT_4(),
				    .D_OUT_5());

  // rule RL_access
  assign CAN_FIRE_RL_access = instReqQ$EMPTY_N && instRespQ$FULL_N ;
  assign WILL_FIRE_RL_access = CAN_FIRE_RL_access ;

  // submodule instReqQ
  assign instReqQ$D_IN = imem_server_request_put ;
  assign instReqQ$ENQ = EN_imem_server_request_put ;
  assign instReqQ$DEQ = CAN_FIRE_RL_access ;
  assign instReqQ$CLR = 1'b0 ;

  // submodule instRespQ
  assign instRespQ$D_IN = { 1'd0, instReqQ$D_OUT[5:0], mem$D_OUT_1 } ;
  assign instRespQ$ENQ = WILL_FIRE_RL_access && !instReqQ$D_OUT[6] ;
  assign instRespQ$DEQ = EN_imem_server_response_get ;
  assign instRespQ$CLR = 1'b0 ;

  // submodule mem
  assign mem$ADDR_1 = instReqQ$D_OUT[5:0] ;
  assign mem$ADDR_2 = 6'h0 ;
  assign mem$ADDR_3 = 6'h0 ;
  assign mem$ADDR_4 = 6'h0 ;
  assign mem$ADDR_5 = 6'h0 ;
  assign mem$ADDR_IN = 6'h0 ;
  assign mem$D_IN = 32'h0 ;
  assign mem$WE = 1'b0 ;
endmodule  // mkImem

