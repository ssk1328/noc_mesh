//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Wed May  7 17:28:06 IST 2014
//
// Method conflict info:
// Method: putDataPacket_put
// Conflict-free: getDataPacket_get, putNoCPacket_put, getNoCPacket_get
// Conflicts: putDataPacket_put
//
// Method: getDataPacket_get
// Conflict-free: putDataPacket_put, putNoCPacket_put, getNoCPacket_get
// Conflicts: getDataPacket_get
//
// Method: putNoCPacket_put
// Conflict-free: putDataPacket_put, getDataPacket_get, getNoCPacket_get
// Conflicts: putNoCPacket_put
//
// Method: getNoCPacket_get
// Conflict-free: putDataPacket_put, getDataPacket_get, putNoCPacket_put
// Conflicts: getNoCPacket_get
//
//
// Ports:
// Name                         I/O  size props
// RDY_putDataPacket_put          O     1 reg
// getDataPacket_get              O    40 reg
// RDY_getDataPacket_get          O     1 reg
// RDY_putNoCPacket_put           O     1 reg
// getNoCPacket_get               O    48 reg
// RDY_getNoCPacket_get           O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// putDataPacket_put              I    40 reg
// putNoCPacket_put               I    48 reg
// EN_putDataPacket_put           I     1
// EN_putNoCPacket_put            I     1
// EN_getDataPacket_get           I     1
// EN_getNoCPacket_get            I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkNetConnect(CLK,
		    RST_N,

		    putDataPacket_put,
		    EN_putDataPacket_put,
		    RDY_putDataPacket_put,

		    EN_getDataPacket_get,
		    getDataPacket_get,
		    RDY_getDataPacket_get,

		    putNoCPacket_put,
		    EN_putNoCPacket_put,
		    RDY_putNoCPacket_put,

		    EN_getNoCPacket_get,
		    getNoCPacket_get,
		    RDY_getNoCPacket_get);
  input  CLK;
  input  RST_N;

  // action method putDataPacket_put
  input  [39 : 0] putDataPacket_put;
  input  EN_putDataPacket_put;
  output RDY_putDataPacket_put;

  // actionvalue method getDataPacket_get
  input  EN_getDataPacket_get;
  output [39 : 0] getDataPacket_get;
  output RDY_getDataPacket_get;

  // action method putNoCPacket_put
  input  [47 : 0] putNoCPacket_put;
  input  EN_putNoCPacket_put;
  output RDY_putNoCPacket_put;

  // actionvalue method getNoCPacket_get
  input  EN_getNoCPacket_get;
  output [47 : 0] getNoCPacket_get;
  output RDY_getNoCPacket_get;

  // signals for module outputs
  wire [47 : 0] getNoCPacket_get;
  wire [39 : 0] getDataPacket_get;
  wire RDY_getDataPacket_get,
       RDY_getNoCPacket_get,
       RDY_putDataPacket_put,
       RDY_putNoCPacket_put;

  // ports of submodule dataPacketInQ
  wire [39 : 0] dataPacketInQ$D_IN, dataPacketInQ$D_OUT;
  wire dataPacketInQ$CLR,
       dataPacketInQ$DEQ,
       dataPacketInQ$EMPTY_N,
       dataPacketInQ$ENQ,
       dataPacketInQ$FULL_N;

  // ports of submodule dataPacketOutQ
  wire [39 : 0] dataPacketOutQ$D_IN, dataPacketOutQ$D_OUT;
  wire dataPacketOutQ$CLR,
       dataPacketOutQ$DEQ,
       dataPacketOutQ$EMPTY_N,
       dataPacketOutQ$ENQ,
       dataPacketOutQ$FULL_N;

  // ports of submodule nocPacketInQ
  wire [47 : 0] nocPacketInQ$D_IN, nocPacketInQ$D_OUT;
  wire nocPacketInQ$CLR,
       nocPacketInQ$DEQ,
       nocPacketInQ$EMPTY_N,
       nocPacketInQ$ENQ,
       nocPacketInQ$FULL_N;

  // ports of submodule nocPacketOutQ
  wire [47 : 0] nocPacketOutQ$D_IN, nocPacketOutQ$D_OUT;
  wire nocPacketOutQ$CLR,
       nocPacketOutQ$DEQ,
       nocPacketOutQ$EMPTY_N,
       nocPacketOutQ$ENQ,
       nocPacketOutQ$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_addLayer,
       CAN_FIRE_RL_removeLayer,
       CAN_FIRE_getDataPacket_get,
       CAN_FIRE_getNoCPacket_get,
       CAN_FIRE_putDataPacket_put,
       CAN_FIRE_putNoCPacket_put,
       WILL_FIRE_RL_addLayer,
       WILL_FIRE_RL_removeLayer,
       WILL_FIRE_getDataPacket_get,
       WILL_FIRE_getNoCPacket_get,
       WILL_FIRE_putDataPacket_put,
       WILL_FIRE_putNoCPacket_put;

  // remaining internal signals
  reg [1 : 0] x__h495, x__h565, x__h576, x__h636;

  // action method putDataPacket_put
  assign RDY_putDataPacket_put = dataPacketInQ$FULL_N ;
  assign CAN_FIRE_putDataPacket_put = dataPacketInQ$FULL_N ;
  assign WILL_FIRE_putDataPacket_put = EN_putDataPacket_put ;

  // actionvalue method getDataPacket_get
  assign getDataPacket_get = dataPacketOutQ$D_OUT ;
  assign RDY_getDataPacket_get = dataPacketOutQ$EMPTY_N ;
  assign CAN_FIRE_getDataPacket_get = dataPacketOutQ$EMPTY_N ;
  assign WILL_FIRE_getDataPacket_get = EN_getDataPacket_get ;

  // action method putNoCPacket_put
  assign RDY_putNoCPacket_put = nocPacketInQ$FULL_N ;
  assign CAN_FIRE_putNoCPacket_put = nocPacketInQ$FULL_N ;
  assign WILL_FIRE_putNoCPacket_put = EN_putNoCPacket_put ;

  // actionvalue method getNoCPacket_get
  assign getNoCPacket_get = nocPacketOutQ$D_OUT ;
  assign RDY_getNoCPacket_get = nocPacketOutQ$EMPTY_N ;
  assign CAN_FIRE_getNoCPacket_get = nocPacketOutQ$EMPTY_N ;
  assign WILL_FIRE_getNoCPacket_get = EN_getNoCPacket_get ;

  // submodule dataPacketInQ
  FIFO2 #(.width(32'd40), .guarded(32'd1)) dataPacketInQ(.RST_N(RST_N),
							 .CLK(CLK),
							 .D_IN(dataPacketInQ$D_IN),
							 .ENQ(dataPacketInQ$ENQ),
							 .DEQ(dataPacketInQ$DEQ),
							 .CLR(dataPacketInQ$CLR),
							 .D_OUT(dataPacketInQ$D_OUT),
							 .FULL_N(dataPacketInQ$FULL_N),
							 .EMPTY_N(dataPacketInQ$EMPTY_N));

  // submodule dataPacketOutQ
  FIFO2 #(.width(32'd40), .guarded(32'd1)) dataPacketOutQ(.RST_N(RST_N),
							  .CLK(CLK),
							  .D_IN(dataPacketOutQ$D_IN),
							  .ENQ(dataPacketOutQ$ENQ),
							  .DEQ(dataPacketOutQ$DEQ),
							  .CLR(dataPacketOutQ$CLR),
							  .D_OUT(dataPacketOutQ$D_OUT),
							  .FULL_N(dataPacketOutQ$FULL_N),
							  .EMPTY_N(dataPacketOutQ$EMPTY_N));

  // submodule nocPacketInQ
  FIFO2 #(.width(32'd48), .guarded(32'd1)) nocPacketInQ(.RST_N(RST_N),
							.CLK(CLK),
							.D_IN(nocPacketInQ$D_IN),
							.ENQ(nocPacketInQ$ENQ),
							.DEQ(nocPacketInQ$DEQ),
							.CLR(nocPacketInQ$CLR),
							.D_OUT(nocPacketInQ$D_OUT),
							.FULL_N(nocPacketInQ$FULL_N),
							.EMPTY_N(nocPacketInQ$EMPTY_N));

  // submodule nocPacketOutQ
  FIFO2 #(.width(32'd48), .guarded(32'd1)) nocPacketOutQ(.RST_N(RST_N),
							 .CLK(CLK),
							 .D_IN(nocPacketOutQ$D_IN),
							 .ENQ(nocPacketOutQ$ENQ),
							 .DEQ(nocPacketOutQ$DEQ),
							 .CLR(nocPacketOutQ$CLR),
							 .D_OUT(nocPacketOutQ$D_OUT),
							 .FULL_N(nocPacketOutQ$FULL_N),
							 .EMPTY_N(nocPacketOutQ$EMPTY_N));

  // rule RL_addLayer
  assign CAN_FIRE_RL_addLayer =
	     dataPacketInQ$EMPTY_N && nocPacketOutQ$FULL_N ;
  assign WILL_FIRE_RL_addLayer = CAN_FIRE_RL_addLayer ;

  // rule RL_removeLayer
  assign CAN_FIRE_RL_removeLayer =
	     nocPacketInQ$EMPTY_N && dataPacketOutQ$FULL_N ;
  assign WILL_FIRE_RL_removeLayer = CAN_FIRE_RL_removeLayer ;

  // submodule dataPacketInQ
  assign dataPacketInQ$D_IN = putDataPacket_put ;
  assign dataPacketInQ$ENQ = EN_putDataPacket_put ;
  assign dataPacketInQ$DEQ = CAN_FIRE_RL_addLayer ;
  assign dataPacketInQ$CLR = 1'b0 ;

  // submodule dataPacketOutQ
  assign dataPacketOutQ$D_IN = nocPacketInQ$D_OUT[39:0] ;
  assign dataPacketOutQ$ENQ = CAN_FIRE_RL_removeLayer ;
  assign dataPacketOutQ$DEQ = EN_getDataPacket_get ;
  assign dataPacketOutQ$CLR = 1'b0 ;

  // submodule nocPacketInQ
  assign nocPacketInQ$D_IN = putNoCPacket_put ;
  assign nocPacketInQ$ENQ = EN_putNoCPacket_put ;
  assign nocPacketInQ$DEQ = CAN_FIRE_RL_removeLayer ;
  assign nocPacketInQ$CLR = 1'b0 ;

  // submodule nocPacketOutQ
  assign nocPacketOutQ$D_IN =
	     { x__h495, x__h565, x__h576, x__h636, dataPacketInQ$D_OUT } ;
  assign nocPacketOutQ$ENQ = CAN_FIRE_RL_addLayer ;
  assign nocPacketOutQ$DEQ = EN_getNoCPacket_get ;
  assign nocPacketOutQ$CLR = 1'b0 ;

  // remaining internal signals
  always@(dataPacketInQ$D_OUT)
  begin
    case (dataPacketInQ$D_OUT[39:36])
      4'd0, 4'd1, 4'd2: x__h495 = 2'd0;
      4'd3, 4'd4, 4'd5: x__h495 = 2'd1;
      4'd6: x__h495 = 2'd2;
      default: x__h495 = 2'd0;
    endcase
  end
  always@(dataPacketInQ$D_OUT)
  begin
    case (dataPacketInQ$D_OUT[39:36])
      4'd0, 4'd3: x__h565 = 2'd0;
      4'd1, 4'd4: x__h565 = 2'd1;
      4'd2, 4'd5: x__h565 = 2'd2;
      default: x__h565 = 2'd0;
    endcase
  end
  always@(dataPacketInQ$D_OUT)
  begin
    case (dataPacketInQ$D_OUT[35:32])
      4'd0, 4'd1, 4'd2: x__h576 = 2'd0;
      4'd3, 4'd4, 4'd5: x__h576 = 2'd1;
      4'd6: x__h576 = 2'd2;
      default: x__h576 = 2'd0;
    endcase
  end
  always@(dataPacketInQ$D_OUT)
  begin
    case (dataPacketInQ$D_OUT[35:32])
      4'd0, 4'd3: x__h636 = 2'd0;
      4'd1, 4'd4: x__h636 = 2'd1;
      4'd2, 4'd5: x__h636 = 2'd2;
      default: x__h636 = 2'd0;
    endcase
  end
endmodule  // mkNetConnect

