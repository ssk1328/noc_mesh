//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Wed May  7 17:28:05 IST 2014
//
// Method conflict info:
// Method: dmem_server_request_put
// Conflict-free: dmem_server_response_get, dumpMem_startDump, dumpMem_doneDump
// Conflicts: dmem_server_request_put
//
// Method: dmem_server_response_get
// Conflict-free: dmem_server_request_put, dumpMem_startDump, dumpMem_doneDump
// Conflicts: dmem_server_response_get
//
// Method: dumpMem_startDump
// Conflict-free: dmem_server_request_put, dmem_server_response_get
// Sequenced before (restricted): dumpMem_startDump
// Sequenced after (restricted): dumpMem_doneDump
//
// Method: dumpMem_doneDump
// Conflict-free: dmem_server_request_put,
// 	       dmem_server_response_get,
// 	       dumpMem_doneDump
// Sequenced before (restricted): dumpMem_startDump
//
//
// Ports:
// Name                         I/O  size props
// RDY_dmem_server_request_put    O     1 reg
// dmem_server_response_get       O    44 reg
// RDY_dmem_server_response_get   O     1 reg
// RDY_dumpMem_startDump          O     1 const
// dumpMem_doneDump               O     1
// RDY_dumpMem_doneDump           O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// dmem_server_request_put        I    39 reg
// EN_dmem_server_request_put     I     1
// EN_dumpMem_startDump           I     1
// EN_dmem_server_response_get    I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkDmem(CLK,
	      RST_N,

	      dmem_server_request_put,
	      EN_dmem_server_request_put,
	      RDY_dmem_server_request_put,

	      EN_dmem_server_response_get,
	      dmem_server_response_get,
	      RDY_dmem_server_response_get,

	      EN_dumpMem_startDump,
	      RDY_dumpMem_startDump,

	      dumpMem_doneDump,
	      RDY_dumpMem_doneDump);
  parameter [3 : 0] procId = 4'b0;
  input  CLK;
  input  RST_N;

  // action method dmem_server_request_put
  input  [38 : 0] dmem_server_request_put;
  input  EN_dmem_server_request_put;
  output RDY_dmem_server_request_put;

  // actionvalue method dmem_server_response_get
  input  EN_dmem_server_response_get;
  output [43 : 0] dmem_server_response_get;
  output RDY_dmem_server_response_get;

  // action method dumpMem_startDump
  input  EN_dumpMem_startDump;
  output RDY_dumpMem_startDump;

  // value method dumpMem_doneDump
  output dumpMem_doneDump;
  output RDY_dumpMem_doneDump;

  // signals for module outputs
  wire [43 : 0] dmem_server_response_get;
  wire RDY_dmem_server_request_put,
       RDY_dmem_server_response_get,
       RDY_dumpMem_doneDump,
       RDY_dumpMem_startDump,
       dumpMem_doneDump;

  // register counter
  reg [5 : 0] counter;
  wire [5 : 0] counter$D_IN;
  wire counter$EN;

  // register dumpFile
  reg [31 : 0] dumpFile;
  wire [31 : 0] dumpFile$D_IN;
  wire dumpFile$EN;

  // register dumpState
  reg [1 : 0] dumpState;
  reg [1 : 0] dumpState$D_IN;
  wire dumpState$EN;

  // ports of submodule dataReqQ
  wire [38 : 0] dataReqQ$D_IN, dataReqQ$D_OUT;
  wire dataReqQ$CLR,
       dataReqQ$DEQ,
       dataReqQ$EMPTY_N,
       dataReqQ$ENQ,
       dataReqQ$FULL_N;

  // ports of submodule dataRespQ
  wire [43 : 0] dataRespQ$D_IN, dataRespQ$D_OUT;
  wire dataRespQ$CLR,
       dataRespQ$DEQ,
       dataRespQ$EMPTY_N,
       dataRespQ$ENQ,
       dataRespQ$FULL_N;

  // ports of submodule mem
  wire [31 : 0] mem$D_IN, mem$D_OUT_1, mem$D_OUT_2;
  wire [5 : 0] mem$ADDR_1,
	       mem$ADDR_2,
	       mem$ADDR_3,
	       mem$ADDR_4,
	       mem$ADDR_5,
	       mem$ADDR_IN;
  wire mem$WE;

  // rule scheduling signals
  wire CAN_FIRE_RL_access,
       CAN_FIRE_RL_closeDumpFile,
       CAN_FIRE_RL_dumpMemory,
       CAN_FIRE_RL_openDumpFile,
       CAN_FIRE_dmem_server_request_put,
       CAN_FIRE_dmem_server_response_get,
       CAN_FIRE_dumpMem_startDump,
       WILL_FIRE_RL_access,
       WILL_FIRE_RL_closeDumpFile,
       WILL_FIRE_RL_dumpMemory,
       WILL_FIRE_RL_openDumpFile,
       WILL_FIRE_dmem_server_request_put,
       WILL_FIRE_dmem_server_response_get,
       WILL_FIRE_dumpMem_startDump;

  // inputs to muxes for submodule ports
  wire [1 : 0] MUX_dumpState$write_1__VAL_3, MUX_dumpState$write_1__VAL_4;

  // remaining internal signals
  reg [31 : 0] x__h889;
  wire [5 : 0] IF_counter_BIT_5_THEN_NEG_counter_ELSE_counter__q1,
	       _0_CONCAT_IF_counter_6_BIT_5_7_THEN_NEG_counter_ETC___d56;

  // action method dmem_server_request_put
  assign RDY_dmem_server_request_put = dataReqQ$FULL_N ;
  assign CAN_FIRE_dmem_server_request_put = dataReqQ$FULL_N ;
  assign WILL_FIRE_dmem_server_request_put = EN_dmem_server_request_put ;

  // actionvalue method dmem_server_response_get
  assign dmem_server_response_get = dataRespQ$D_OUT ;
  assign RDY_dmem_server_response_get = dataRespQ$EMPTY_N ;
  assign CAN_FIRE_dmem_server_response_get = dataRespQ$EMPTY_N ;
  assign WILL_FIRE_dmem_server_response_get = EN_dmem_server_response_get ;

  // action method dumpMem_startDump
  assign RDY_dumpMem_startDump = 1'd1 ;
  assign CAN_FIRE_dumpMem_startDump = 1'd1 ;
  assign WILL_FIRE_dumpMem_startDump = EN_dumpMem_startDump ;

  // value method dumpMem_doneDump
  assign dumpMem_doneDump = dumpState == 2'd3 ;
  assign RDY_dumpMem_doneDump = 1'd1 ;

  // submodule dataReqQ
  FIFO2 #(.width(32'd39), .guarded(32'd1)) dataReqQ(.RST_N(RST_N),
						    .CLK(CLK),
						    .D_IN(dataReqQ$D_IN),
						    .ENQ(dataReqQ$ENQ),
						    .DEQ(dataReqQ$DEQ),
						    .CLR(dataReqQ$CLR),
						    .D_OUT(dataReqQ$D_OUT),
						    .FULL_N(dataReqQ$FULL_N),
						    .EMPTY_N(dataReqQ$EMPTY_N));

  // submodule dataRespQ
  FIFO2 #(.width(32'd44), .guarded(32'd1)) dataRespQ(.RST_N(RST_N),
						     .CLK(CLK),
						     .D_IN(dataRespQ$D_IN),
						     .ENQ(dataRespQ$ENQ),
						     .DEQ(dataRespQ$DEQ),
						     .CLR(dataRespQ$CLR),
						     .D_OUT(dataRespQ$D_OUT),
						     .FULL_N(dataRespQ$FULL_N),
						     .EMPTY_N(dataRespQ$EMPTY_N));

  // submodule mem
  RegFileLoad #(.file((procId == 4'd0) ?
			"../data/dmem/dmem_init_0.txt" :
			((procId == 4'd1) ?
			   "../data/dmem/dmem_init_1.txt" :
			   ((procId == 4'd2) ?
			      "../data/dmem/dmem_init_2.txt" :
			      ((procId == 4'd3) ?
				 "../data/dmem/dmem_init_3.txt" :
				 ((procId == 4'd4) ?
				    "../data/dmem/dmem_init_4.txt" :
				    ((procId == 4'd5) ?
				       "../data/dmem/dmem_init_5.txt" :
				       ((procId == 4'd6) ?
					  "../data/dmem/dmem_init_6.txt" :
					  "../data/dmem/dmem_init_.txt"))))))),
		.addr_width(32'd6),
		.data_width(32'd32),
		.lo(6'd0),
		.hi(6'd63),
		.binary(32'd0)) mem(.CLK(CLK),
				    .ADDR_1(mem$ADDR_1),
				    .ADDR_2(mem$ADDR_2),
				    .ADDR_3(mem$ADDR_3),
				    .ADDR_4(mem$ADDR_4),
				    .ADDR_5(mem$ADDR_5),
				    .ADDR_IN(mem$ADDR_IN),
				    .D_IN(mem$D_IN),
				    .WE(mem$WE),
				    .D_OUT_1(mem$D_OUT_1),
				    .D_OUT_2(mem$D_OUT_2),
				    .D_OUT_3(),
				    .D_OUT_4(),
				    .D_OUT_5());

  // rule RL_openDumpFile
  assign CAN_FIRE_RL_openDumpFile = dumpState == 2'd0 ;
  assign WILL_FIRE_RL_openDumpFile = CAN_FIRE_RL_openDumpFile ;

  // rule RL_dumpMemory
  assign CAN_FIRE_RL_dumpMemory = dumpState == 2'd1 ;
  assign WILL_FIRE_RL_dumpMemory = CAN_FIRE_RL_dumpMemory ;

  // rule RL_closeDumpFile
  assign CAN_FIRE_RL_closeDumpFile = dumpState == 2'd2 ;
  assign WILL_FIRE_RL_closeDumpFile = CAN_FIRE_RL_closeDumpFile ;

  // rule RL_access
  assign CAN_FIRE_RL_access = dataReqQ$EMPTY_N && dataRespQ$FULL_N ;
  assign WILL_FIRE_RL_access = CAN_FIRE_RL_access ;

  // inputs to muxes for submodule ports
  assign MUX_dumpState$write_1__VAL_3 = (counter == 6'd63) ? 2'd2 : 2'd1 ;
  assign MUX_dumpState$write_1__VAL_4 = (x__h889 == 32'd0) ? 2'd3 : 2'd1 ;

  // register counter
  assign counter$D_IN = (counter == 6'd63) ? 6'd0 : counter + 6'd1 ;
  assign counter$EN = CAN_FIRE_RL_dumpMemory ;

  // register dumpFile
  assign dumpFile$D_IN = x__h889 ;
  assign dumpFile$EN = CAN_FIRE_RL_openDumpFile ;

  // register dumpState
  always@(EN_dumpMem_startDump or
	  WILL_FIRE_RL_closeDumpFile or
	  WILL_FIRE_RL_dumpMemory or
	  MUX_dumpState$write_1__VAL_3 or
	  WILL_FIRE_RL_openDumpFile or MUX_dumpState$write_1__VAL_4)
  case (1'b1)
    EN_dumpMem_startDump: dumpState$D_IN = 2'd0;
    WILL_FIRE_RL_closeDumpFile: dumpState$D_IN = 2'd3;
    WILL_FIRE_RL_dumpMemory: dumpState$D_IN = MUX_dumpState$write_1__VAL_3;
    WILL_FIRE_RL_openDumpFile: dumpState$D_IN = MUX_dumpState$write_1__VAL_4;
    default: dumpState$D_IN = 2'b10 /* unspecified value */ ;
  endcase
  assign dumpState$EN =
	     WILL_FIRE_RL_openDumpFile || WILL_FIRE_RL_dumpMemory ||
	     EN_dumpMem_startDump ||
	     WILL_FIRE_RL_closeDumpFile ;

  // submodule dataReqQ
  assign dataReqQ$D_IN = dmem_server_request_put ;
  assign dataReqQ$ENQ = EN_dmem_server_request_put ;
  assign dataReqQ$DEQ = CAN_FIRE_RL_access ;
  assign dataReqQ$CLR = 1'b0 ;

  // submodule dataRespQ
  assign dataRespQ$D_IN =
	     { dataReqQ$D_OUT[38],
	       dataReqQ$D_OUT[38] ?
		 { 36'hAAAAAAAAA, dataReqQ$D_OUT[38:32] } :
		 { dataReqQ$D_OUT[10:5],
		   mem$D_OUT_2,
		   dataReqQ$D_OUT[4:0] } } ;
  assign dataRespQ$ENQ = CAN_FIRE_RL_access ;
  assign dataRespQ$DEQ = EN_dmem_server_response_get ;
  assign dataRespQ$CLR = 1'b0 ;

  // submodule mem
  assign mem$ADDR_1 = counter ;
  assign mem$ADDR_2 = dataReqQ$D_OUT[10:5] ;
  assign mem$ADDR_3 = 6'h0 ;
  assign mem$ADDR_4 = 6'h0 ;
  assign mem$ADDR_5 = 6'h0 ;
  assign mem$ADDR_IN = dataReqQ$D_OUT[37:32] ;
  assign mem$D_IN = dataReqQ$D_OUT[31:0] ;
  assign mem$WE = WILL_FIRE_RL_access && dataReqQ$D_OUT[38] ;

  // remaining internal signals
  assign IF_counter_BIT_5_THEN_NEG_counter_ELSE_counter__q1 =
	     counter[5] ? -counter : counter ;
  assign _0_CONCAT_IF_counter_6_BIT_5_7_THEN_NEG_counter_ETC___d56 =
	     { 2'd0,
	       IF_counter_BIT_5_THEN_NEG_counter_ELSE_counter__q1[3:0] } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        counter <= `BSV_ASSIGNMENT_DELAY 6'd0;
	dumpFile <= `BSV_ASSIGNMENT_DELAY 32'd0;
	dumpState <= `BSV_ASSIGNMENT_DELAY 2'd3;
      end
    else
      begin
        if (counter$EN) counter <= `BSV_ASSIGNMENT_DELAY counter$D_IN;
	if (dumpFile$EN) dumpFile <= `BSV_ASSIGNMENT_DELAY dumpFile$D_IN;
	if (dumpState$EN) dumpState <= `BSV_ASSIGNMENT_DELAY dumpState$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    counter = 6'h2A;
    dumpFile = 32'hAAAAAAAA;
    dumpState = 2'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N)
      if (WILL_FIRE_RL_openDumpFile)
	if (procId == 4'd0)
	  begin
	    x__h889 = $fopen("../data/dmem/dmem_dump_0.txt", "w");
	    #0;
	  end
	else
	  if (procId == 4'd1)
	    begin
	      x__h889 = $fopen("../data/dmem/dmem_dump_1.txt", "w");
	      #0;
	    end
	  else
	    if (procId == 4'd2)
	      begin
	        x__h889 = $fopen("../data/dmem/dmem_dump_2.txt", "w");
		#0;
	      end
	    else
	      if (procId == 4'd3)
		begin
		  x__h889 = $fopen("../data/dmem/dmem_dump_3.txt", "w");
		  #0;
		end
	      else
		if (procId == 4'd4)
		  begin
		    x__h889 = $fopen("../data/dmem/dmem_dump_4.txt", "w");
		    #0;
		  end
		else
		  if (procId == 4'd5)
		    begin
		      x__h889 = $fopen("../data/dmem/dmem_dump_5.txt", "w");
		      #0;
		    end
		  else
		    if (procId == 4'd6)
		      begin
		        x__h889 = $fopen("../data/dmem/dmem_dump_6.txt", "w");
			#0;
		      end
		    else
		      begin
		        x__h889 = $fopen("../data/dmem/dmem_dump_.txt", "w");
			#0;
		      end
    if (RST_N)
      if (WILL_FIRE_RL_openDumpFile && x__h889 == 32'd0)
	if (procId == 4'd0)
	  $display("cannot open %s. Error. Failed to Dump. Exiting",
		   "../data/dmem/dmem_dump_0.txt");
	else
	  if (procId == 4'd1)
	    $display("cannot open %s. Error. Failed to Dump. Exiting",
		     "../data/dmem/dmem_dump_1.txt");
	  else
	    if (procId == 4'd2)
	      $display("cannot open %s. Error. Failed to Dump. Exiting",
		       "../data/dmem/dmem_dump_2.txt");
	    else
	      if (procId == 4'd3)
		$display("cannot open %s. Error. Failed to Dump. Exiting",
			 "../data/dmem/dmem_dump_3.txt");
	      else
		if (procId == 4'd4)
		  $display("cannot open %s. Error. Failed to Dump. Exiting",
			   "../data/dmem/dmem_dump_4.txt");
		else
		  if (procId == 4'd5)
		    $display("cannot open %s. Error. Failed to Dump. Exiting",
			     "../data/dmem/dmem_dump_5.txt");
		  else
		    if (procId == 4'd6)
		      $display("cannot open %s. Error. Failed to Dump. Exiting",
			       "../data/dmem/dmem_dump_6.txt");
		    else
		      $display("cannot open %s. Error. Failed to Dump. Exiting",
			       "../data/dmem/dmem_dump_.txt");
    if (RST_N)
      if (WILL_FIRE_RL_dumpMemory &&
	  (counter[5] ?
	     -_0_CONCAT_IF_counter_6_BIT_5_7_THEN_NEG_counter_ETC___d56 :
	     _0_CONCAT_IF_counter_6_BIT_5_7_THEN_NEG_counter_ETC___d56) ==
	  6'd0)
	$fwrite(dumpFile, "@%x\n%8x\n", $signed(counter), mem$D_OUT_1);
    if (RST_N)
      if (WILL_FIRE_RL_dumpMemory &&
	  (counter[5] ?
	     -_0_CONCAT_IF_counter_6_BIT_5_7_THEN_NEG_counter_ETC___d56 :
	     _0_CONCAT_IF_counter_6_BIT_5_7_THEN_NEG_counter_ETC___d56) !=
	  6'd0)
	$fwrite(dumpFile, "%8x\n", mem$D_OUT_1);
    if (RST_N) if (WILL_FIRE_RL_closeDumpFile) $fclose(dumpFile);
  end
  // synopsys translate_on
endmodule  // mkDmem

