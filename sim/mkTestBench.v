//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Wed May  7 20:12:19 IST 2014
//
// Method conflict info:
// (none)
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkTestBench(CLK,
		   RST_N);
  input  CLK;
  input  RST_N;

  // register done
  reg done;
  wire done$D_IN, done$EN;

  // ports of submodule dut
  wire dut$EN_dumpDataMem_0_startDump,
       dut$EN_dumpDataMem_1_startDump,
       dut$EN_dumpDataMem_2_startDump,
       dut$EN_dumpDataMem_3_startDump,
       dut$EN_dumpDataMem_4_startDump,
       dut$EN_dumpDataMem_5_startDump,
       dut$EN_dumpDataMem_6_startDump,
       dut$coreStatus_0_getState,
       dut$coreStatus_1_getState,
       dut$coreStatus_2_getState,
       dut$coreStatus_3_getState,
       dut$coreStatus_4_getState,
       dut$coreStatus_5_getState,
       dut$coreStatus_6_getState,
       dut$dumpDataMem_0_doneDump,
       dut$dumpDataMem_1_doneDump,
       dut$dumpDataMem_2_doneDump,
       dut$dumpDataMem_3_doneDump,
       dut$dumpDataMem_4_doneDump,
       dut$dumpDataMem_5_doneDump,
       dut$dumpDataMem_6_doneDump;

  // rule scheduling signals
  wire CAN_FIRE_RL_checkHalt,
       CAN_FIRE_RL_finishSim,
       WILL_FIRE_RL_checkHalt,
       WILL_FIRE_RL_finishSim;

  // remaining internal signals
  wire dut_coreStatus_6_getState_AND_dut_coreStatus_5_ETC___d15,
       dut_dumpDataMem_6_doneDump__6_AND_dut_dumpData_ETC___d28;

  // submodule dut
  mkSystem dut(.CLK(CLK),
	       .RST_N(RST_N),
	       .EN_dumpDataMem_0_startDump(dut$EN_dumpDataMem_0_startDump),
	       .EN_dumpDataMem_1_startDump(dut$EN_dumpDataMem_1_startDump),
	       .EN_dumpDataMem_2_startDump(dut$EN_dumpDataMem_2_startDump),
	       .EN_dumpDataMem_3_startDump(dut$EN_dumpDataMem_3_startDump),
	       .EN_dumpDataMem_4_startDump(dut$EN_dumpDataMem_4_startDump),
	       .EN_dumpDataMem_5_startDump(dut$EN_dumpDataMem_5_startDump),
	       .EN_dumpDataMem_6_startDump(dut$EN_dumpDataMem_6_startDump),
	       .coreStatus_0_getState(dut$coreStatus_0_getState),
	       .RDY_coreStatus_0_getState(),
	       .coreStatus_1_getState(dut$coreStatus_1_getState),
	       .RDY_coreStatus_1_getState(),
	       .coreStatus_2_getState(dut$coreStatus_2_getState),
	       .RDY_coreStatus_2_getState(),
	       .coreStatus_3_getState(dut$coreStatus_3_getState),
	       .RDY_coreStatus_3_getState(),
	       .coreStatus_4_getState(dut$coreStatus_4_getState),
	       .RDY_coreStatus_4_getState(),
	       .coreStatus_5_getState(dut$coreStatus_5_getState),
	       .RDY_coreStatus_5_getState(),
	       .coreStatus_6_getState(dut$coreStatus_6_getState),
	       .RDY_coreStatus_6_getState(),
	       .RDY_dumpDataMem_0_startDump(),
	       .dumpDataMem_0_doneDump(dut$dumpDataMem_0_doneDump),
	       .RDY_dumpDataMem_0_doneDump(),
	       .RDY_dumpDataMem_1_startDump(),
	       .dumpDataMem_1_doneDump(dut$dumpDataMem_1_doneDump),
	       .RDY_dumpDataMem_1_doneDump(),
	       .RDY_dumpDataMem_2_startDump(),
	       .dumpDataMem_2_doneDump(dut$dumpDataMem_2_doneDump),
	       .RDY_dumpDataMem_2_doneDump(),
	       .RDY_dumpDataMem_3_startDump(),
	       .dumpDataMem_3_doneDump(dut$dumpDataMem_3_doneDump),
	       .RDY_dumpDataMem_3_doneDump(),
	       .RDY_dumpDataMem_4_startDump(),
	       .dumpDataMem_4_doneDump(dut$dumpDataMem_4_doneDump),
	       .RDY_dumpDataMem_4_doneDump(),
	       .RDY_dumpDataMem_5_startDump(),
	       .dumpDataMem_5_doneDump(dut$dumpDataMem_5_doneDump),
	       .RDY_dumpDataMem_5_doneDump(),
	       .RDY_dumpDataMem_6_startDump(),
	       .dumpDataMem_6_doneDump(dut$dumpDataMem_6_doneDump),
	       .RDY_dumpDataMem_6_doneDump());

  // rule RL_finishSim
  assign CAN_FIRE_RL_finishSim = done ;
  assign WILL_FIRE_RL_finishSim = done ;

  // rule RL_checkHalt
  assign CAN_FIRE_RL_checkHalt = !done ;
  assign WILL_FIRE_RL_checkHalt = CAN_FIRE_RL_checkHalt ;

  // register done
  assign done$D_IN = 1'd1 ;
  assign done$EN =
	     WILL_FIRE_RL_checkHalt &&
	     dut_coreStatus_6_getState_AND_dut_coreStatus_5_ETC___d15 ;

  // submodule dut
  assign dut$EN_dumpDataMem_0_startDump =
	     WILL_FIRE_RL_checkHalt &&
	     dut_coreStatus_6_getState_AND_dut_coreStatus_5_ETC___d15 ;
  assign dut$EN_dumpDataMem_1_startDump =
	     WILL_FIRE_RL_checkHalt &&
	     dut_coreStatus_6_getState_AND_dut_coreStatus_5_ETC___d15 ;
  assign dut$EN_dumpDataMem_2_startDump =
	     WILL_FIRE_RL_checkHalt &&
	     dut_coreStatus_6_getState_AND_dut_coreStatus_5_ETC___d15 ;
  assign dut$EN_dumpDataMem_3_startDump =
	     WILL_FIRE_RL_checkHalt &&
	     dut_coreStatus_6_getState_AND_dut_coreStatus_5_ETC___d15 ;
  assign dut$EN_dumpDataMem_4_startDump =
	     WILL_FIRE_RL_checkHalt &&
	     dut_coreStatus_6_getState_AND_dut_coreStatus_5_ETC___d15 ;
  assign dut$EN_dumpDataMem_5_startDump =
	     WILL_FIRE_RL_checkHalt &&
	     dut_coreStatus_6_getState_AND_dut_coreStatus_5_ETC___d15 ;
  assign dut$EN_dumpDataMem_6_startDump =
	     WILL_FIRE_RL_checkHalt &&
	     dut_coreStatus_6_getState_AND_dut_coreStatus_5_ETC___d15 ;

  // remaining internal signals
  assign dut_coreStatus_6_getState_AND_dut_coreStatus_5_ETC___d15 =
	     dut$coreStatus_6_getState && dut$coreStatus_5_getState &&
	     dut$coreStatus_4_getState &&
	     dut$coreStatus_3_getState &&
	     dut$coreStatus_2_getState &&
	     dut$coreStatus_1_getState &&
	     dut$coreStatus_0_getState ;
  assign dut_dumpDataMem_6_doneDump__6_AND_dut_dumpData_ETC___d28 =
	     dut$dumpDataMem_6_doneDump && dut$dumpDataMem_5_doneDump &&
	     dut$dumpDataMem_4_doneDump &&
	     dut$dumpDataMem_3_doneDump &&
	     dut$dumpDataMem_2_doneDump &&
	     dut$dumpDataMem_1_doneDump &&
	     dut$dumpDataMem_0_doneDump ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        done <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (done$EN) done <= `BSV_ASSIGNMENT_DELAY done$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    done = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N)
      if (done && dut_dumpDataMem_6_doneDump__6_AND_dut_dumpData_ETC___d28)
	$display("Simulation Completed **SUCESSFULLY**");
    if (RST_N)
      if (done && dut_dumpDataMem_6_doneDump__6_AND_dut_dumpData_ETC___d28)
	$finish(32'd1);
  end
  // synopsys translate_on
endmodule  // mkTestBench

